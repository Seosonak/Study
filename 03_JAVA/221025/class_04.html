<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>클래스 static</title>
</head>
<body>
    <script>
        //속성+메소드
         class Pet {  
            static color = 'black' //정적 속성(static 속성)

            //constructor : 생성자 함수 
            constructor(nameVal, ageVal, catVal) {
                //속성
                this.name = nameVal
                this.age = ageVal
                this.cat = catVal
            } 
            
            //메소드 함수
            eat (food) { //함수
                console.log(`${this.name}이가 ${food}를 먹습니다.`) // >이미 객체가 생성되어있어서
            }  //food는 매개변수로 받아와야함

            //나이출력
            agePrint () {
                console.log(`${this.name}의 나이는 ${this.age}입니다.`)
            }
            //종 출력
            catPrint () {
                console.log(`${this.name}의 종운 ${this.cat}입니다.`)
            }


            static namePrint () { //정적 메소드(static 메소드)
                //console.log(`${this.color}입니다`)
                console.log(`검은색 입니다`)
            }
        }

        //function과 static의 차이점 클래스에 가깝게 관리할 수 있다
        function colorPrint() {
            console.log(`검은색입니다`)
        }


        //static을 붙인애들은 new를 붙이지 않아도 출력가능 클래스명.속성으로 메소드 가져오기가능
        const pet = new Pet('구름', 7, '코숏')
        //const pet2 = new Pet('별', 3, '페르시안')

        console.log(Pet.color)
        console.log(Pet.colorPrint())
        colorPrint()



        /*
        pet.eat('통조림')
        pet.agePrint()
        pet.catPrint()

        pet2.eat('통조림')
        pet2.agePrint()
        pet2.catPrint()
        */
    </script>
</body>
</html>